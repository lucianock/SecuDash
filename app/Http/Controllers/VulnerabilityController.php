<?php

namespace App\Http\Controllers;

use App\Services\AdvancedVulnerabilityScanner;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\View\View;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;

class VulnerabilityController extends Controller
{
    private $scanner;

    public function __construct(AdvancedVulnerabilityScanner $scanner)
    {
        $this->scanner = $scanner;
    }

    public function index(): View
    {
        return view('vulnerability.index');
    }

    public function scan(Request $request): JsonResponse
    {
        if (!$request->ajax()) {
            return response()->json([
                'error' => 'This endpoint only accepts AJAX requests'
            ], 400);
        }

        try {
            Log::info('Scan request received', $request->all());
            
            // Validar la entrada
            $validated = $request->validate([
                'target_url' => 'required|url',
                'scan_type' => 'required|in:quick,full,penetration',
                'scan_depth' => 'nullable|in:basic,standard,aggressive',
                'custom_checks' => 'nullable|array',
            ]);

            Log::info('Validation passed', $validated);

            // Generar ID único para el escaneo
            $scanId = 'scan_' . uniqid() . '_' . time();
            
            // Para escaneos rápidos, procesar inmediatamente
            if ($validated['scan_type'] === 'quick') {
                $results = $this->generateFakeVulnerabilityResults($validated);
                
                return response()->json([
                    'status' => 'completed',
                    'scan_id' => $scanId,
                    'target_url' => $validated['target_url'],
                    'scan_type' => $validated['scan_type'],
                    'message' => 'Quick scan completed',
                    'results' => $results
                ]);
            }
            
            // Para escaneos completos, simular procesamiento en background
            $this->simulateScanProgress($scanId, $validated);

            return response()->json([
                'status' => 'queued',
                'scan_id' => $scanId,
                'target_url' => $validated['target_url'],
                'scan_type' => $validated['scan_type'],
                'message' => 'Scan queued successfully'
            ]);

        } catch (\Exception $e) {
            Log::error('Scan error', [
                'message' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);

            return response()->json([
                'error' => 'An error occurred while scanning.',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    private function simulateScanProgress(string $scanId, array $validated): void
    {
        // Simular progreso del escaneo - completar inmediatamente para demo
        $results = $this->generateFakeVulnerabilityResults($validated);
        
        Cache::put("scan_status:{$scanId}", [
            'status' => 'completed',
            'progress' => 100,
            'message' => 'Scan completed successfully',
            'results' => $results,
            'scan_id' => $scanId,
            'target_url' => $validated['target_url'],
            'scan_type' => $validated['scan_type']
        ], 3600);
    }

    private function generateFakeVulnerabilityResults(array $validated): array
    {
        $targetUrl = $validated['target_url'];
        $scanType = $validated['scan_type'];
        
        // Generar número de vulnerabilidades basado en el tipo de escaneo
        $vulnerabilityCount = $scanType === 'quick' ? rand(2, 5) : rand(5, 12);
        
        $vulnerabilities = [];
        $summary = ['high' => 0, 'medium' => 0, 'low' => 0, 'total' => 0];
        
        $vulnerabilityTypes = $this->getVulnerabilityTypes($scanType);
        
        for ($i = 0; $i < $vulnerabilityCount; $i++) {
            $type = $vulnerabilityTypes[array_rand($vulnerabilityTypes)];
            $vulnerability = $this->generateVulnerability($type, $targetUrl);
            $vulnerabilities[] = $vulnerability;
            $summary[$vulnerability['severity']]++;
        }
        
        $summary['total'] = count($vulnerabilities);
        
        return [
            'scan_id' => 'scan_' . uniqid() . '_' . time(),
            'timestamp' => now()->toISOString(),
            'target_url' => $targetUrl,
            'scan_type' => $scanType,
            'vulnerabilities' => $vulnerabilities,
            'summary' => $summary,
            'scan_metadata' => [
                'scanner_version' => '1.0',
                'scan_duration' => rand(5, 30),
                'definitions_count' => count($vulnerabilityTypes),
                'status' => 'completed'
            ]
        ];
    }

    private function getVulnerabilityTypes(string $scanType): array
    {
        $types = [
            'SQL Injection',
            'Cross-Site Scripting (XSS)',
            'Security Misconfiguration',
            'Broken Access Control',
            'Sensitive Data Exposure',
            'Missing Security Headers',
            'Open Port Detection',
            'Parameter Injection Vulnerability',
            'Server Information Disclosure',
            'Sensitive Resource Exposed'
        ];
        
        if ($scanType === 'quick') {
            return array_slice($types, 0, 5);
        }
        
        return $types;
    }

    private function generateVulnerability(string $type, string $targetUrl): array
    {
        $vulnerabilityData = $this->getVulnerabilityData($type);
        $location = $this->generateLocation($targetUrl);
        
        // Determinar severidad basada en el tipo de vulnerabilidad
        $severity = match($type) {
            'SQL Injection', 'Cross-Site Scripting (XSS)', 'Broken Access Control' => 'high',
            'Security Misconfiguration', 'Sensitive Data Exposure' => 'medium',
            default => 'low'
        };
        
        return [
            'severity' => $severity,
            'type' => $type,
            'description' => $vulnerabilityData['description'],
            'location' => $location,
            'owasp_category' => $vulnerabilityData['owasp_category'],
            'cve_ids' => $vulnerabilityData['cve_ids'],
            'exploitation_methods' => $vulnerabilityData['exploitation_methods'],
            'mitigation_steps' => $vulnerabilityData['mitigation_steps'],
            'references' => $vulnerabilityData['references'],
            'example_payloads' => $vulnerabilityData['example_payloads'] ?? []
        ];
    }

    private function getVulnerabilityData(string $type): array
    {
        $data = [
            'SQL Injection' => [
                'description' => 'Application is vulnerable to SQL injection attacks through unvalidated user input',
                'owasp_category' => 'A03:2021-Injection',
                'cve_ids' => ['CVE-2021-28163', 'CVE-2021-42013'],
                'exploitation_methods' => [
                    'Using single quotes to break SQL queries',
                    'UNION-based attacks to extract data',
                    'Boolean-based blind injection',
                    'Time-based blind injection'
                ],
                'mitigation_steps' => [
                    'Use prepared statements or parameterized queries',
                    'Implement proper input validation and sanitization',
                    'Use ORM frameworks with built-in protection',
                    'Implement WAF (Web Application Firewall)'
                ],
                'references' => [
                    'https://owasp.org/www-community/attacks/SQL_Injection',
                    'https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html'
                ],
                'example_payloads' => [
                    "' OR '1'='1",
                    "1' UNION SELECT null,version()--",
                    "1' AND SLEEP(5)--"
                ]
            ],
            'Cross-Site Scripting (XSS)' => [
                'description' => 'Application allows execution of malicious scripts through unvalidated user input',
                'owasp_category' => 'A03:2021-Injection',
                'cve_ids' => ['CVE-2021-42013', 'CVE-2021-28164'],
                'exploitation_methods' => [
                    'Reflected XSS through URL parameters',
                    'Stored XSS in user-generated content',
                    'DOM-based XSS manipulation',
                    'Event handler injection'
                ],
                'mitigation_steps' => [
                    'Implement proper output encoding',
                    'Use Content Security Policy (CSP)',
                    'Validate and sanitize all user inputs',
                    'Use security libraries for output encoding'
                ],
                'references' => [
                    'https://owasp.org/www-community/attacks/xss/',
                    'https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html'
                ],
                'example_payloads' => [
                    '<script>alert("XSS")</script>',
                    '<img src=x onerror=alert("XSS")>',
                    '<svg onload=alert("XSS")>'
                ]
            ],
            'Security Misconfiguration' => [
                'description' => 'Application has security headers missing or improperly configured',
                'owasp_category' => 'A05:2021-Security Misconfiguration',
                'cve_ids' => ['CVE-2021-44228', 'CVE-2021-28165'],
                'exploitation_methods' => [
                    'Exploiting default configurations',
                    'Accessing sensitive files and directories',
                    'Information disclosure through error messages',
                    'Privilege escalation through misconfiguration'
                ],
                'mitigation_steps' => [
                    'Implement security headers (CSP, HSTS, etc.)',
                    'Remove default accounts and passwords',
                    'Configure proper error handling',
                    'Regular security configuration reviews'
                ],
                'references' => [
                    'https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration',
                    'https://cheatsheetseries.owasp.org/cheatsheets/Security_Headers_Cheat_Sheet.html'
                ],
                'example_payloads' => []
            ],
            'Broken Access Control' => [
                'description' => 'Application fails to properly restrict access to resources',
                'owasp_category' => 'A01:2021-Broken Access Control',
                'cve_ids' => ['CVE-2021-28166', 'CVE-2021-42014'],
                'exploitation_methods' => [
                    'Horizontal privilege escalation',
                    'Vertical privilege escalation',
                    'Insecure direct object references (IDOR)',
                    'Force browsing to restricted resources'
                ],
                'mitigation_steps' => [
                    'Implement proper authentication and authorization',
                    'Use role-based access control (RBAC)',
                    'Validate user permissions for each request',
                    'Implement proper session management'
                ],
                'references' => [
                    'https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control',
                    'https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html'
                ],
                'example_payloads' => []
            ],
            'Sensitive Data Exposure' => [
                'description' => 'Application exposes sensitive information in responses or logs',
                'owasp_category' => 'A02:2021-Cryptographic Failures',
                'cve_ids' => ['CVE-2021-28167', 'CVE-2021-42015'],
                'exploitation_methods' => [
                    'Information disclosure through error messages',
                    'Sensitive data in HTTP headers',
                    'Unencrypted data transmission',
                    'Weak encryption algorithms'
                ],
                'mitigation_steps' => [
                    'Encrypt sensitive data at rest and in transit',
                    'Use strong encryption algorithms',
                    'Implement proper error handling',
                    'Regular security audits'
                ],
                'references' => [
                    'https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure',
                    'https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html'
                ],
                'example_payloads' => []
            ]
        ];
        
        return $data[$type] ?? [
            'description' => 'Security vulnerability detected',
            'owasp_category' => 'A00:2021-General',
            'cve_ids' => ['CVE-2021-00000'],
            'exploitation_methods' => ['General exploitation methods'],
            'mitigation_steps' => ['Implement security best practices'],
            'references' => ['https://owasp.org/'],
            'example_payloads' => []
        ];
    }

    private function generateLocation(string $targetUrl): string
    {
        $locations = [
            $targetUrl,
            $targetUrl . '/api/users',
            $targetUrl . '/admin',
            $targetUrl . '/login',
            $targetUrl . '/search',
            $targetUrl . '/profile',
            $targetUrl . '/api/data',
            $targetUrl . '/config',
            $targetUrl . '/backup',
            $targetUrl . '/test'
        ];
        
        return $locations[array_rand($locations)];
    }

    public function status(string $scanId): JsonResponse
    {
        try {
            $status = Cache::get("scan_status:{$scanId}");
            
            if (!$status) {
                return response()->json([
                    'error' => 'Scan not found or expired'
                ], 404);
            }

            return response()->json($status);
            
        } catch (\Exception $e) {
            Log::error('Status check error', [
                'scan_id' => $scanId,
                'error' => $e->getMessage()
            ]);
            
            return response()->json([
                'error' => 'Error checking scan status',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    public function exportReport(string $scanId): JsonResponse
    {
        try {
            $status = Cache::get("scan_status:{$scanId}");
            
            if (!$status || $status['status'] !== 'completed') {
                return response()->json([
                    'error' => 'Scan not found or not completed'
                ], 404);
            }
            
            $results = $status['results'];
            $executiveSummary = $this->generateExecutiveSummary($results);
            $remediationPlan = $this->generateRemediationPlan($results);
            $complianceStatus = $this->generateComplianceStatus($results['vulnerabilities']);
            
            $report = [
                'scan_id' => $scanId,
                'timestamp' => now()->toISOString(),
                'target_url' => $results['target_url'],
                'scan_type' => $results['scan_type'],
                'executive_summary' => $executiveSummary,
                'vulnerabilities' => $results['vulnerabilities'],
                'summary' => $results['summary'],
                'remediation_plan' => $remediationPlan,
                'compliance_status' => $complianceStatus,
                'risk_assessment' => [
                    'overall_risk_score' => $this->calculateRiskScore($results['summary']),
                    'business_impact' => $this->assessBusinessImpact($results['summary']),
                    'remediation_time' => $this->estimateRemediationTime($results['summary']),
                    'remediation_cost' => $this->estimateRemediationCost($results['summary'])
                ]
            ];
            
            return response()->json($report);
            
        } catch (\Exception $e) {
            Log::error('Export report error', [
                'scan_id' => $scanId,
                'error' => $e->getMessage()
            ]);
            
            return response()->json([
                'error' => 'Error generating report',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    private function generateExecutiveSummary(array $results): array
    {
        $summary = $results['summary'];
        $totalVulns = $summary['total'];
        $highRisk = $summary['high'];
        $mediumRisk = $summary['medium'];
        $lowRisk = $summary['low'];
        
        return [
            'total_vulnerabilities' => $totalVulns,
            'high_risk_count' => $highRisk,
            'medium_risk_count' => $mediumRisk,
            'low_risk_count' => $lowRisk,
            'overall_risk_level' => $highRisk > 0 ? 'High' : ($mediumRisk > 0 ? 'Medium' : 'Low'),
            'critical_findings' => $highRisk,
            'recommendations' => [
                'Address high-risk vulnerabilities immediately',
                'Implement security best practices',
                'Regular security assessments',
                'Employee security training'
            ]
        ];
    }

    private function assessBusinessImpact(array $summary): string
    {
        $highRisk = $summary['high'];
        $mediumRisk = $summary['medium'];
        
        if ($highRisk > 3) return 'Critical';
        if ($highRisk > 0 || $mediumRisk > 5) return 'High';
        if ($mediumRisk > 2) return 'Medium';
        return 'Low';
    }

    private function estimateRemediationTime(array $summary): string
    {
        $total = $summary['total'];
        $high = $summary['high'];
        
        if ($high > 3) return '4-6 weeks';
        if ($high > 0 || $total > 10) return '2-4 weeks';
        if ($total > 5) return '1-2 weeks';
        return '3-5 days';
    }

    private function estimateRemediationCost(array $summary): string
    {
        $total = $summary['total'];
        $high = $summary['high'];
        
        if ($high > 3) return '$50,000 - $100,000';
        if ($high > 0 || $total > 10) return '$25,000 - $50,000';
        if ($total > 5) return '$10,000 - $25,000';
        return '$5,000 - $10,000';
    }

    private function generateRemediationPlan(array $results): array
    {
        return [
            'immediate_actions' => [
                'Address all high-risk vulnerabilities within 24 hours',
                'Implement temporary security measures',
                'Notify stakeholders of critical findings'
            ],
            'short_term' => [
                'Fix medium-risk vulnerabilities within 1 week',
                'Implement security headers',
                'Update security policies'
            ],
            'long_term' => [
                'Establish regular security assessments',
                'Implement automated security testing',
                'Security training for development team'
            ],
            'priority_order' => [
                'SQL Injection vulnerabilities',
                'Cross-Site Scripting vulnerabilities',
                'Missing security headers',
                'Broken access controls',
                'Information disclosure issues'
            ]
        ];
    }

    private function generateComplianceStatus(array $vulnerabilities): array
    {
        $compliance = [
            'owasp_top_10' => 'Non-Compliant',
            'pci_dss' => 'Non-Compliant',
            'gdpr' => 'Non-Compliant',
            'sox' => 'Non-Compliant'
        ];
        
        $highRiskCount = count(array_filter($vulnerabilities, fn($v) => $v['severity'] === 'high'));
        
        if ($highRiskCount === 0) {
            $compliance['owasp_top_10'] = 'Compliant';
            $compliance['pci_dss'] = 'Partially Compliant';
        }
        
        return $compliance;
    }

    private function calculateRiskScore(array $summary): int
    {
        $score = 0;
        $score += $summary['high'] * 10;
        $score += $summary['medium'] * 5;
        $score += $summary['low'] * 2;
        
        return min(100, $score);
    }
} 