<?php

namespace App\Services;

use GuzzleHttp\Client;
use GuzzleHttp\Exception\GuzzleException;
use Illuminate\Support\Facades\Log;
use App\Models\VulnerabilityDefinition;
use Illuminate\Support\Facades\Queue;
use App\Jobs\FullVulnerabilityScan;
use Illuminate\Support\Facades\Cache;

class AdvancedVulnerabilityScanner
{
    private $client;
    private $vulnerabilities = [];
    private $summary = [
        'high' => 0,
        'medium' => 0,
        'low' => 0,
        'total' => 0
    ];

    public function __construct()
    {
        $this->client = new Client([
            'timeout' => 30,
            'verify' => false,
            'http_errors' => false,
            'headers' => [
                'User-Agent' => 'SecuDash Security Scanner/1.0'
            ]
        ]);
    }

    public function scan(string $url, string $scanType): array
    {
        try {
            Log::info('Starting advanced vulnerability scan', ['url' => $url, 'type' => $scanType]);
            
            // Generate a unique scan ID
            $scanId = uniqid();
            
            // For full scans, we'll queue the intensive operations
            if ($scanType === 'full') {
                // Dispatch background job for full scan
                dispatch(new FullVulnerabilityScan($url, $scanId));
                
                // Return immediate response with scan ID
                return [
                    'scan_id' => $scanId,
                    'timestamp' => now(),
                    'target_url' => $url,
                    'scan_type' => $scanType,
                    'status' => 'queued',
                    'message' => 'Full scan has been queued and will be processed in the background.',
                    'vulnerabilities' => [],
                    'summary' => ['high' => 0, 'medium' => 0, 'low' => 0, 'total' => 0],
                    'scan_metadata' => [
                        'scanner_version' => '1.0',
                        'scan_duration' => 0,
                        'status' => 'in_progress'
                    ]
                ];
            }
            
            // For quick scans, continue with synchronous processing
            $this->vulnerabilities = [];
            $this->summary = ['high' => 0, 'medium' => 0, 'low' => 0, 'total' => 0];

            // Obtener todas las definiciones de vulnerabilidades
            $definitions = VulnerabilityDefinition::all();
            Log::info('Loaded vulnerability definitions', ['count' => $definitions->count()]);

            // Verificación inicial de la URL
            try {
                $response = $this->client->get($url);
                Log::info('Initial URL check successful', [
                    'status_code' => $response->getStatusCode(),
                    'headers' => $response->getHeaders()
                ]);
            } catch (\Exception $e) {
                Log::warning('Initial URL check failed', ['error' => $e->getMessage()]);
                $this->addVulnerability(
                    'medium',
                    'Connectivity Issue',
                    'Unable to establish a connection to the target URL',
                    $url,
                    'Verify the URL is accessible and the server is running',
                    [],
                    'A05:2021-Security Misconfiguration'
                );
            }

            // Verificar headers de seguridad básicos
            $this->checkSecurityHeaders($url);

            foreach ($definitions as $definition) {
                Log::info('Checking vulnerability', ['type' => $definition->name]);
                $this->checkVulnerability($url, $definition);
            }

            // Verificaciones adicionales específicas
            if ($scanType === 'full') {
                Log::info('Performing full scan additional checks');
                $this->performActiveScanning($url, $scanType);
            }

            $result = [
                'scan_id' => uniqid(),
                'timestamp' => now(),
                'target_url' => $url,
                'scan_type' => $scanType,
                'vulnerabilities' => $this->vulnerabilities,
                'summary' => $this->summary,
                'scan_metadata' => [
                    'scanner_version' => '1.0',
                    'definitions_count' => $definitions->count(),
                    'scan_duration' => time() - LARAVEL_START,
                ]
            ];

            Log::info('Scan completed', [
                'vulnerabilities_found' => count($this->vulnerabilities),
                'summary' => $this->summary
            ]);

            return $result;

        } catch (\Exception | GuzzleException $e) {
            Log::error('Scan error', [
                'message' => $e->getMessage(),
                'url' => $url
            ]);
            throw $e;
        }
    }

    /**
     * Perform a full vulnerability scan with detailed progress tracking
     */
    public function performFullScan(string $url, string $scanId): array
    {
        try {
            $startTime = microtime(true);
            $this->vulnerabilities = [];
            $this->summary = ['high' => 0, 'medium' => 0, 'low' => 0, 'total' => 0];

            // Update status to indicate scan has started
            Cache::put("scan_status:{$scanId}", [
                'status' => 'running',
                'progress' => 0,
                'message' => 'Starting security headers check...',
                'elapsed_time' => 0
            ], 3600);

            // 1. Check Security Headers (10%)
            $this->checkSecurityHeaders($url);
            $this->updateScanProgress($scanId, 10, 'Checking for basic vulnerabilities...', $startTime);

            // 2. Load and check vulnerability definitions (30%)
            $definitions = VulnerabilityDefinition::all();
            foreach ($definitions as $index => $definition) {
                $this->checkVulnerability($url, $definition);
                $progress = 10 + (20 * ($index + 1) / max(1, $definitions->count()));
                $this->updateScanProgress($scanId, $progress, "Analyzing vulnerability patterns...", $startTime);
            }

            // 3. Port Scanning (50%)
            $this->updateScanProgress($scanId, 40, 'Starting port scan...', $startTime);
            $this->scanCommonPorts($url);
            $this->updateScanProgress($scanId, 50, 'Port scan completed', $startTime);

            // 4. Parameter Fuzzing (70%)
            $this->updateScanProgress($scanId, 60, 'Testing parameters...', $startTime);
            $this->performParameterFuzzing($url);
            $this->updateScanProgress($scanId, 70, 'Parameter testing completed', $startTime);

            // 5. Injection Testing (90%)
            $this->updateScanProgress($scanId, 80, 'Testing for injection vulnerabilities...', $startTime);
            $this->testForInjections($url);
            $this->updateScanProgress($scanId, 90, 'Injection testing completed', $startTime);

            // 6. Resource Enumeration (100%)
            $this->updateScanProgress($scanId, 95, 'Enumerating resources...', $startTime);
            $this->enumerateResources($url);

            // Prepare final results
            $results = [
                'scan_id' => $scanId,
                'timestamp' => now(),
                'target_url' => $url,
                'scan_type' => 'full',
                'vulnerabilities' => $this->vulnerabilities,
                'summary' => $this->summary,
                'scan_metadata' => [
                    'scanner_version' => '1.0',
                    'definitions_count' => $definitions->count(),
                    'scan_duration' => round(microtime(true) - $startTime, 2),
                ]
            ];

            // Update final status with results
            Cache::put("scan_status:{$scanId}", [
                'status' => 'completed',
                'progress' => 100,
                'message' => 'Scan completed successfully',
                'elapsed_time' => round(microtime(true) - $startTime, 2),
                'results' => $results
            ], 3600);

            return $results;

        } catch (\Exception $e) {
            Log::error('Full scan failed', [
                'scan_id' => $scanId,
                'error' => $e->getMessage()
            ]);

            Cache::put("scan_status:{$scanId}", [
                'status' => 'failed',
                'error' => $e->getMessage(),
                'elapsed_time' => round(microtime(true) - $startTime, 2)
            ], 3600);

            throw $e;
        }
    }

    private function updateScanProgress(string $scanId, int $progress, string $message, float $startTime): void
    {
        Cache::put("scan_status:{$scanId}", [
            'status' => 'running',
            'progress' => $progress,
            'message' => $message,
            'elapsed_time' => round(microtime(true) - $startTime, 2)
        ], 3600);
    }

    private function checkVulnerability(string $url, VulnerabilityDefinition $definition): void
    {
        try {
            $response = $this->client->get($url);
            $body = (string) $response->getBody();
            $headers = $response->getHeaders();

            // Verificar patrones de detección
            foreach ($definition->detection_patterns as $pattern) {
                $safePattern = preg_quote($pattern, '/');
                if (preg_match("/{$safePattern}/i", $body)) {
                    // Verificar falsos positivos
                    if (!$this->isFalsePositive($body, $definition->false_positives)) {
                        $this->addDetailedVulnerability($definition, $url);
                        break;
                    }
                }
            }

            // Verificaciones específicas según el tipo de vulnerabilidad
            $this->performSpecificChecks($url, $definition, $body, $headers);

        } catch (\Exception $e) {
            Log::warning("Error checking {$definition->name}: {$e->getMessage()}");
        }
    }

    private function performActiveScanning(string $url, string $scanType): void
    {
        if ($scanType === 'full') {
            // Escaneo de puertos comunes
            $this->scanCommonPorts($url);
            
            // Fuzzing de parámetros
            $this->performParameterFuzzing($url);
            
            // Pruebas de inyección
            $this->testForInjections($url);
            
            // Enumeración de recursos
            $this->enumerateResources($url);
        }
    }

    private function scanCommonPorts(string $url): void
    {
        $parsedUrl = parse_url($url);
        $host = $parsedUrl['host'];
        $commonPorts = [80, 443, 8080, 8443, 3000, 4000, 5000];

        foreach ($commonPorts as $port) {
            try {
                $client = new Client(['timeout' => 2]);
                $response = $client->get("http://{$host}:{$port}");
                
                if ($response->getStatusCode() < 400) {
                    $this->addVulnerability(
                        'medium',
                        'Open Port Detected',
                        "Port {$port} is open and accessible",
                        "{$host}:{$port}",
                        "Review if this port needs to be exposed and properly secure it if necessary",
                        ['CVE-2021-3129'],
                        'A05:2021-Security Misconfiguration',
                        ['Verify firewall rules', 'Implement port filtering']
                    );
                }
            } catch (\Exception $e) {
                continue;
            }
        }
    }

    private function performParameterFuzzing(string $url): void
    {
        $commonParameters = ['id', 'user', 'file', 'page', 'action', 'type'];
        $testValues = ["'", "<script>", "../", "1=1", "*", "%00"];

        foreach ($commonParameters as $param) {
            foreach ($testValues as $value) {
                try {
                    $testUrl = $url . "?{$param}=" . urlencode($value);
                    $response = $this->client->get($testUrl);
                    $body = (string) $response->getBody();

                    // Analizar respuesta por patrones de error o comportamiento anómalo
                    if (strpos($body, 'error') !== false || 
                        strpos($body, 'exception') !== false || 
                        strpos($body, 'warning') !== false) {
                        
                        $this->addVulnerability(
                            'high',
                            'Parameter Injection Vulnerability',
                            "Parameter {$param} appears to be vulnerable to injection",
                            $testUrl,
                            "Implement proper input validation and sanitization",
                            ['CVE-2021-28163'],
                            'A03:2021-Injection',
                            ['Use parameterized queries', 'Implement input validation']
                        );
                    }
                } catch (\Exception $e) {
                    continue;
                }
            }
        }
    }

    private function testForInjections(string $url): void
    {
        $injectionTests = [
            'sql' => [
                "' OR '1'='1",
                "1; DROP TABLE users--",
                "1' UNION SELECT null,version()--"
            ],
            'xss' => [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "<svg onload=alert('XSS')>"
            ],
            'command' => [
                "|ls",
                "& ping 127.0.0.1",
                "; cat /etc/passwd"
            ]
        ];

        foreach ($injectionTests as $type => $payloads) {
            foreach ($payloads as $payload) {
                try {
                    $response = $this->client->post($url, [
                        'form_params' => ['test' => $payload]
                    ]);
                    
                    $body = (string) $response->getBody();
                    
                    // Analizar respuesta por indicadores de vulnerabilidad
                    if ($this->detectsInjectionSuccess($body, $type)) {
                        $this->addVulnerability(
                            'high',
                            ucfirst($type) . ' Injection Vulnerability',
                            "Application appears vulnerable to {$type} injection",
                            $url,
                            "Implement proper input validation and sanitization for {$type}",
                            ['CVE-2021-28163'],
                            'A03:2021-Injection',
                            ['Use prepared statements', 'Implement WAF']
                        );
                    }
                } catch (\Exception $e) {
                    continue;
                }
            }
        }
    }

    private function enumerateResources(string $url): void
    {
        $commonResources = [
            '/admin',
            '/api',
            '/backup',
            '/config',
            '/dev',
            '/test',
            '/phpinfo.php',
            '/.git',
            '/.env',
            '/wp-admin',
            '/console',
            '/actuator'
        ];

        foreach ($commonResources as $resource) {
            try {
                $response = $this->client->get($url . $resource);
                
                if ($response->getStatusCode() === 200) {
                    $this->addVulnerability(
                        'high',
                        'Sensitive Resource Exposed',
                        "Sensitive resource {$resource} is accessible",
                        $url . $resource,
                        "Restrict access to sensitive resources",
                        ['CVE-2021-28164'],
                        'A01:2021-Broken Access Control',
                        ['Implement access controls', 'Move sensitive resources']
                    );
                }
            } catch (\Exception $e) {
                continue;
            }
        }
    }

    private function detectsInjectionSuccess(string $body, string $type): bool
    {
        $indicators = [
            'sql' => [
                'mysql_error',
                'ORA-',
                'SQL syntax',
                'PostgreSQL',
                'SQLite3'
            ],
            'xss' => [
                '<script>',
                'onerror=',
                'javascript:',
                'alert('
            ],
            'command' => [
                'root:x:',
                'bin/bash',
                'Directory of',
                'Volume Serial Number'
            ]
        ];

        foreach ($indicators[$type] as $indicator) {
            if (stripos($body, $indicator) !== false) {
                return true;
            }
        }

        return false;
    }

    private function isFalsePositive(string $content, array $falsePositives): bool
    {
        foreach ($falsePositives as $pattern) {
            $safePattern = preg_quote($pattern, '/');
            if (preg_match("/{$safePattern}/i", $content)) {
                return true;
            }
        }
        return false;
    }

    private function performSpecificChecks(string $url, VulnerabilityDefinition $definition, string $body, array $headers): void
    {
        switch ($definition->name) {
            case 'SQL Injection':
                $this->performSQLInjectionChecks($url);
                break;
            case 'Cross-Site Scripting (XSS)':
                $this->performXSSChecks($url, $body);
                break;
            case 'Security Misconfiguration':
                $this->performSecurityMisconfigurationChecks($headers);
                break;
            // Agregar más casos específicos según sea necesario
        }
    }

    private function addDetailedVulnerability(VulnerabilityDefinition $definition, string $url): void
    {
        $this->vulnerabilities[] = [
            'severity' => $definition->severity,
            'type' => $definition->name,
            'description' => $definition->description,
            'location' => $url,
            'owasp_category' => $definition->owasp_category,
            'cve_ids' => $definition->cve_ids,
            'exploitation_methods' => $definition->exploitation_methods,
            'mitigation_steps' => $definition->mitigation_steps,
            'references' => $definition->references,
            'example_payloads' => $definition->example_payloads
        ];

        $this->summary[$definition->severity]++;
        $this->summary['total']++;
    }

    private function addVulnerability(
        string $severity,
        string $type,
        string $description,
        string $location,
        string $recommendation,
        array $cveIds = [],
        string $owaspCategory = '',
        array $mitigationSteps = [],
        array $exploitationMethods = [],
        array $references = []
    ): void {
        $this->vulnerabilities[] = [
            'severity' => $severity,
            'type' => $type,
            'description' => $description,
            'location' => $location,
            'recommendation' => $recommendation,
            'cve_ids' => $cveIds,
            'owasp_category' => $owaspCategory,
            'mitigation_steps' => $mitigationSteps,
            'exploitation_methods' => $exploitationMethods,
            'references' => $references
        ];

        $this->summary[$severity]++;
        $this->summary['total']++;
    }

    private function performSQLInjectionChecks(string $url): void
    {
        $payloads = [
            "' OR '1'='1",
            "1' UNION SELECT NULL--",
            "1' AND SLEEP(5)--",
            "1' AND 1=CONVERT(int,@@version)--"
        ];

        foreach ($payloads as $payload) {
            try {
                $startTime = microtime(true);
                $response = $this->client->get($url . "?id=" . urlencode($payload));
                $endTime = microtime(true);
                $duration = $endTime - $startTime;

                // Detectar respuestas que indican éxito de SQL injection
                if ($duration > 5 || 
                    strpos($response->getBody(), 'mysql') !== false ||
                    strpos($response->getBody(), 'SQL') !== false) {
                    
                    $this->addVulnerability(
                        'high',
                        'SQL Injection Vulnerability',
                        'Application appears vulnerable to SQL injection attacks',
                        $url,
                        'Use prepared statements and input validation',
                        ['CVE-2021-28163'],
                        'A03:2021-Injection',
                        ['Use prepared statements', 'Implement WAF']
                    );
                    break;
                }
            } catch (\Exception $e) {
                continue;
            }
        }
    }

    private function performXSSChecks(string $url, string $body): void
    {
        // Verificar si hay contextos potencialmente vulnerables
        if (preg_match('/<input.*value=["\'](.*?)["\']/', $body) ||
            preg_match('/<textarea>(.*?)<\/textarea>/', $body) ||
            preg_match('/\$\(.*\)\.html\(/', $body)) {
            
            $this->addVulnerability(
                'high',
                'Potential XSS Vulnerability',
                'Application contains unescaped output in dangerous contexts',
                $url,
                'Implement proper output encoding',
                ['CVE-2021-42013'],
                'A03:2021-Injection',
                ['Use HTML encoding', 'Implement CSP']
            );
        }
    }

    private function performSecurityMisconfigurationChecks(array $headers): void
    {
        $requiredHeaders = [
            'X-Frame-Options',
            'X-Content-Type-Options',
            'X-XSS-Protection',
            'Content-Security-Policy',
            'Strict-Transport-Security'
        ];

        foreach ($requiredHeaders as $header) {
            if (!isset($headers[$header])) {
                $this->addVulnerability(
                    'medium',
                    'Missing Security Header',
                    "The {$header} header is not set",
                    'HTTP Headers',
                    "Add the {$header} header with appropriate values",
                    ['CVE-2021-44228'],
                    'A05:2021-Security Misconfiguration',
                    ['Configure security headers', 'Use security middleware']
                );
            }
        }
    }

    private function checkSecurityHeaders(string $url): void
    {
        try {
            $response = $this->client->head($url);
            $headers = $response->getHeaders();
            
            $securityHeaders = [
                'X-Frame-Options' => [
                    'description' => 'Missing X-Frame-Options header increases clickjacking risks',
                    'exploitation_methods' => [
                        'Embedding the target site in an iframe to conduct clickjacking attacks',
                        'Using UI redressing techniques to trick users into clicking malicious elements',
                        'Creating transparent overlays over legitimate buttons/forms'
                    ],
                    'mitigation_steps' => [
                        'Add X-Frame-Options header with DENY or SAMEORIGIN value',
                        'Implement frame-ancestors directive in Content-Security-Policy',
                        'Use security middleware to automatically set security headers',
                        'Consider implementing JavaScript frame-busting code as an additional layer'
                    ],
                    'references' => [
                        'https://owasp.org/www-community/attacks/Clickjacking',
                        'https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options',
                        'https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html'
                    ]
                ],
                'X-Content-Type-Options' => [
                    'description' => 'Missing X-Content-Type-Options header increases MIME-sniffing risks',
                    'exploitation_methods' => [
                        'Uploading malicious files with misleading extensions',
                        'Exploiting browser MIME-sniffing to execute malicious content',
                        'Content-type spoofing attacks'
                    ],
                    'mitigation_steps' => [
                        'Add X-Content-Type-Options header with nosniff value',
                        'Properly set Content-Type headers for all responses',
                        'Implement strict file upload validation',
                        'Use content-type verification in your application'
                    ],
                    'references' => [
                        'https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options',
                        'https://owasp.org/www-project-secure-headers/#x-content-type-options',
                        'https://www.keycdn.com/support/x-content-type-options'
                    ]
                ],
                'X-XSS-Protection' => [
                    'description' => 'Missing X-XSS-Protection header increases XSS risks',
                    'exploitation_methods' => [
                        'Injecting malicious scripts through unvalidated input',
                        'Exploiting reflected XSS vulnerabilities',
                        'DOM-based XSS attacks'
                    ],
                    'mitigation_steps' => [
                        'Add X-XSS-Protection header with "1; mode=block"',
                        'Implement proper input validation and output encoding',
                        'Use Content-Security-Policy as a stronger alternative',
                        'Sanitize all user inputs and API responses'
                    ],
                    'references' => [
                        'https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection',
                        'https://owasp.org/www-community/attacks/xss/',
                        'https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html'
                    ]
                ],
                'Content-Security-Policy' => [
                    'description' => 'Missing Content-Security-Policy header increases XSS and injection risks',
                    'exploitation_methods' => [
                        'Loading resources from untrusted sources',
                        'Executing inline scripts and styles',
                        'Exploiting unsafe-eval and unsafe-inline directives'
                    ],
                    'mitigation_steps' => [
                        'Implement a strict Content-Security-Policy',
                        'Use nonce or hash for trusted inline scripts',
                        'Define allowed sources for all resource types',
                        'Regularly audit and update CSP rules'
                    ],
                    'references' => [
                        'https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP',
                        'https://content-security-policy.com/',
                        'https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html'
                    ]
                ],
                'Strict-Transport-Security' => [
                    'description' => 'Missing HSTS header increases MitM attack risks',
                    'exploitation_methods' => [
                        'SSL stripping attacks',
                        'Protocol downgrade attacks',
                        'Cookie hijacking through insecure connections'
                    ],
                    'mitigation_steps' => [
                        'Add Strict-Transport-Security header with appropriate max-age',
                        'Consider including includeSubDomains directive',
                        'Submit site to HSTS preload list',
                        'Ensure proper SSL/TLS configuration'
                    ],
                    'references' => [
                        'https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security',
                        'https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Strict_Transport_Security_Cheat_Sheet.html',
                        'https://hstspreload.org/'
                    ]
                ],
                'Referrer-Policy' => [
                    'description' => 'Missing Referrer-Policy header may leak sensitive information',
                    'exploitation_methods' => [
                        'Information leakage through referrer headers',
                        'Cross-origin information disclosure',
                        'User privacy compromises'
                    ],
                    'mitigation_steps' => [
                        'Add Referrer-Policy header with appropriate value',
                        'Consider using strict-origin-when-cross-origin',
                        'Review and adjust based on application needs',
                        'Test cross-origin scenarios'
                    ],
                    'references' => [
                        'https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy',
                        'https://web.dev/referrer-best-practices/',
                        'https://www.w3.org/TR/referrer-policy/'
                    ]
                ]
            ];

            foreach ($securityHeaders as $header => $info) {
                if (!isset($headers[$header])) {
                    $this->addVulnerability(
                        'medium',
                        'Missing Security Header: ' . $header,
                        $info['description'],
                        $url,
                        "Add the {$header} header with appropriate values",
                        [],
                        'A05:2021-Security Misconfiguration',
                        $info['mitigation_steps'],
                        $info['exploitation_methods'],
                        $info['references']
                    );
                }
            }

            // Verificar Server header exposure
            if (isset($headers['Server'])) {
                $this->addVulnerability(
                    'low',
                    'Server Information Disclosure',
                    'Server header reveals server software information',
                    $url,
                    'Remove or modify the Server header to hide server information',
                    [],
                    'A05:2021-Security Misconfiguration',
                    ['Configure server to hide version information', 'Use security middleware to remove/modify Server header'],
                    ['Fingerprinting server software version', 'Targeting known vulnerabilities'],
                    [
                        'https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/01-Information_Gathering/02-Fingerprint_Web_Server',
                        'https://www.acunetix.com/blog/articles/server-banners-attack-vectors/'
                    ]
                );
            }
        } catch (\Exception $e) {
            Log::warning('Failed to check security headers', ['error' => $e->getMessage()]);
        }
    }
} 