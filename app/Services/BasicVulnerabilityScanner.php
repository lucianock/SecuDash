<?php

namespace App\Services;

use GuzzleHttp\Client;
use GuzzleHttp\Exception\GuzzleException;
use Illuminate\Support\Facades\Log;

class BasicVulnerabilityScanner
{
    private $client;
    private $vulnerabilities = [];
    private $summary = [
        'high' => 0,
        'medium' => 0,
        'low' => 0,
        'total' => 0
    ];

    public function __construct()
    {
        $this->client = new Client([
            'timeout' => 10,
            'verify' => false, // Permitir certificados autofirmados
            'http_errors' => false // No lanzar excepciones en errores HTTP
        ]);
    }

    public function scan(string $url, string $scanType): array
    {
        try {
            Log::info('Starting basic vulnerability scan', ['url' => $url, 'type' => $scanType]);
            
            // Limpiar resultados anteriores
            $this->vulnerabilities = [];
            $this->summary = ['high' => 0, 'medium' => 0, 'low' => 0, 'total' => 0];

            // Realizar verificaciones básicas
            $this->checkSecurityHeaders($url);
            $this->checkSSLTLS($url);
            $this->checkCSRF($url);
            $this->checkInfoDisclosure($url);
            
            if ($scanType === 'full') {
                // Verificaciones adicionales para escaneo completo
                $this->checkDirectoryListing($url);
                $this->checkDefaultPages($url);
                $this->checkErrorPages($url);
            }

            return [
                'scan_id' => uniqid(),
                'timestamp' => now(),
                'target_url' => $url,
                'scan_type' => $scanType,
                'vulnerabilities' => $this->vulnerabilities,
                'summary' => $this->summary
            ];

        } catch (\Exception | GuzzleException $e) {
            Log::error('Scan error', [
                'message' => $e->getMessage(),
                'url' => $url
            ]);
            throw $e;
        }
    }

    private function addVulnerability(string $severity, string $type, string $description, string $location, string $recommendation): void
    {
        $this->vulnerabilities[] = [
            'severity' => $severity,
            'type' => $type,
            'description' => $description,
            'location' => $location,
            'recommendation' => $recommendation
        ];

        $this->summary[$severity]++;
        $this->summary['total']++;
    }

    private function checkSecurityHeaders(string $url): void
    {
        try {
            $response = $this->client->head($url);
            $headers = $response->getHeaders();

            $securityHeaders = [
                'X-Frame-Options' => [
                    'severity' => 'medium',
                    'description' => 'Missing X-Frame-Options header - Site might be vulnerable to clickjacking',
                    'recommendation' => 'Add X-Frame-Options header with DENY or SAMEORIGIN value'
                ],
                'X-Content-Type-Options' => [
                    'severity' => 'low',
                    'description' => 'Missing X-Content-Type-Options header - Potential MIME-sniffing risk',
                    'recommendation' => 'Add X-Content-Type-Options header with nosniff value'
                ],
                'Strict-Transport-Security' => [
                    'severity' => 'high',
                    'description' => 'Missing HSTS header - Site vulnerable to SSL/TLS downgrade attacks',
                    'recommendation' => 'Add Strict-Transport-Security header with appropriate max-age'
                ],
                'Content-Security-Policy' => [
                    'severity' => 'medium',
                    'description' => 'Missing Content Security Policy - Site vulnerable to XSS and injection attacks',
                    'recommendation' => 'Implement a proper Content Security Policy'
                ]
            ];

            foreach ($securityHeaders as $header => $info) {
                if (!isset($headers[$header])) {
                    $this->addVulnerability(
                        $info['severity'],
                        "Missing Security Header: {$header}",
                        $info['description'],
                        $url,
                        $info['recommendation']
                    );
                }
            }
        } catch (\Exception $e) {
            Log::warning("Error checking security headers: {$e->getMessage()}");
        }
    }

    private function checkSSLTLS(string $url): void
    {
        if (!str_starts_with($url, 'https://')) {
            $this->addVulnerability(
                'high',
                'No SSL/TLS',
                'Site is not using HTTPS - All traffic is unencrypted',
                $url,
                'Implement HTTPS using a valid SSL/TLS certificate'
            );
        }
    }

    private function checkCSRF(string $url): void
    {
        try {
            $response = $this->client->get($url);
            $body = (string) $response->getBody();
            
            // Buscar formularios sin token CSRF
            if (preg_match('/<form/i', $body) && !preg_match('/<input[^>]*(_token|csrf)/i', $body)) {
                $this->addVulnerability(
                    'high',
                    'CSRF Vulnerability',
                    'Forms detected without CSRF protection',
                    $url,
                    'Implement CSRF tokens in all forms'
                );
            }
        } catch (\Exception $e) {
            Log::warning("Error checking CSRF: {$e->getMessage()}");
        }
    }

    private function checkInfoDisclosure(string $url): void
    {
        try {
            $response = $this->client->get($url);
            $body = (string) $response->getBody();
            
            // Buscar patrones de información sensible
            $patterns = [
                'error_reporting\(E_ALL\)' => 'PHP error reporting enabled',
                'mysql_' => 'MySQL function calls exposed',
                'mysqli_' => 'MySQLi function calls exposed',
                'PostgreSQL.*ERROR' => 'PostgreSQL error messages',
                'SQLSTATE\[[0-9]+\]' => 'SQL error messages',
                'stack trace' => 'Stack traces exposed',
                '\<!--.*TODO' => 'Developer comments found'
            ];

            foreach ($patterns as $pattern => $description) {
                if (preg_match("/{$pattern}/i", $body)) {
                    $this->addVulnerability(
                        'medium',
                        'Information Disclosure',
                        "Sensitive information exposed: {$description}",
                        $url,
                        'Remove or disable debug information in production'
                    );
                }
            }
        } catch (\Exception $e) {
            Log::warning("Error checking information disclosure: {$e->getMessage()}");
        }
    }

    private function checkDirectoryListing(string $url): void
    {
        $commonDirs = ['images', 'uploads', 'backup', 'admin', 'test'];
        
        foreach ($commonDirs as $dir) {
            try {
                $response = $this->client->get(rtrim($url, '/') . '/' . $dir);
                $body = (string) $response->getBody();
                
                if ($response->getStatusCode() == 200 && 
                    (strpos($body, 'Index of /') !== false || strpos($body, '<directory>') !== false)) {
                    $this->addVulnerability(
                        'medium',
                        'Directory Listing Enabled',
                        "Directory listing is enabled for /{$dir}",
                        $url . '/' . $dir,
                        'Disable directory listing in server configuration'
                    );
                }
            } catch (\Exception $e) {
                continue;
            }
        }
    }

    private function checkDefaultPages(string $url): void
    {
        $defaultPages = [
            'phpinfo.php' => 'PHP Info page',
            'test.php' => 'Test page',
            'info.php' => 'Info page',
            'admin.php' => 'Admin page',
            'wp-admin' => 'WordPress admin',
            'administrator' => 'Joomla admin'
        ];

        foreach ($defaultPages as $page => $description) {
            try {
                $response = $this->client->get(rtrim($url, '/') . '/' . $page);
                if ($response->getStatusCode() == 200) {
                    $this->addVulnerability(
                        'high',
                        'Default Page Exposed',
                        "{$description} is accessible",
                        $url . '/' . $page,
                        'Remove or protect default pages in production'
                    );
                }
            } catch (\Exception $e) {
                continue;
            }
        }
    }

    private function checkErrorPages(string $url): void
    {
        $errorCodes = [403, 404, 500];
        
        foreach ($errorCodes as $code) {
            try {
                $response = $this->client->get(rtrim($url, '/') . '/nonexistent' . $code);
                $body = (string) $response->getBody();
                
                if (preg_match('/(exception|stack trace|error|warning)/i', $body)) {
                    $this->addVulnerability(
                        'medium',
                        'Verbose Error Messages',
                        "Error page {$code} reveals sensitive information",
                        $url . '/nonexistent' . $code,
                        'Implement custom error pages with minimal information'
                    );
                }
            } catch (\Exception $e) {
                continue;
            }
        }
    }
} 